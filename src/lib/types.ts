// Define the structure for a token identified by the lexer
export interface Token {
  token: string; // The actual lexeme (e.g., "if", "myVariable", "+")
  type: TokenType; // The category of the token (e.g., KEYWORD, IDENTIFIER)
  line: number; // The line number where the token starts
  column: number; // The column number where the token starts
}

// Define the possible types a token can have
export type TokenType =
  | 'KEYWORD'
  | 'IDENTIFIER'
  | 'LITERAL_STRING'
  | 'LITERAL_NUMBER'
  | 'LITERAL_BOOLEAN'
  | 'LITERAL_CHAR'
  | 'OPERATOR'
  | 'PUNCTUATION' // Includes separators like ;, ,, (, ), {, }, [, ]
  | 'COMMENT_SINGLE' // Kept for internal lexing logic, filtered for UI
  | 'COMMENT_MULTI'  // Kept for internal lexing logic, filtered for UI
  | 'WHITESPACE'     // Kept for internal lexing logic, filtered for UI
  | 'ERROR';         // For internal error logging, filtered for UI

// Define the structure for an entry in the symbol table based on detailed rules
export interface SymbolTableEntry {
  lexeme: string;         // Actual string or token from source code
  tokenType: TokenType;   // Category: identifier, keyword, constant, operator, etc.
  dataType: string | null; // Data type of the lexeme (if applicable)
  scope: string;          // Scope level (e.g., "global", "function:main", "block:10:5")
  memoryLocation?: string;// Optional: Address or relative position (usually added later)
  lineNumbers: number[];  // Source code line numbers where the symbol appears/is used
  size?: number;          // Optional: Size in bytes (for arrays, strings, etc.)
  attributes?: {          // Optional: Any additional info
    isConstant?: boolean;
    value?: any;          // For constants
    dimensions?: number[]; // For arrays
    // Add other relevant attributes as needed
  };
}

// Define the structure for lexeme statistics
export interface LexemeStat {
  type: TokenType; // The type of lexeme being counted
  count: number; // The number of times this type of lexeme appeared
  frequency: number; // The percentage frequency of this lexeme type (count / total tokens)
}

// Define the overall result structure returned by the lexer
// Note: Intermediate Code (Quadruples, Triples, Indirect Triples) generation
// is now handled by a separate Genkit flow.
export interface LexerResult {
  tokens: Token[]; // List of all valid tokens found (filtered for UI display)
  symbolTable: SymbolTableEntry[]; // The generated symbol table
  lexemeStats: LexemeStat[]; // Statistics about lexeme types
  tac: string[]; // Basic Three-Address Code instructions generated during lexical analysis
}

// Define the structure for a Three-Address Code instruction (generated by lexer.ts)
// This is a basic representation, more complex IC is handled by AI flow.
export interface TacInstruction {
    line: number;       // Original source line number related to this TAC
    operator: string | null; // Operator (e.g., '+', '-', 'assign', 'goto', 'if_false_goto')
    arg1: string | null;     // First argument/operand (variable, constant, temporary, label)
    arg2: string | null;     // Second argument/operand
    result: string | null;   // Result (variable, temporary, label)
}
